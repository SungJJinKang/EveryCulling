한국어 설명 :                

우선 전체 스크린 버퍼를 32 X 8로 나눈다.            
이렇게 스크린 버퍼를 32 X 8 타일 단위로 나누어서 얻는 이점은 멀티스레딩에서 각 스레드들이 각기 다른 타일에서 연산을 하기 때문에 스레드간 동기화, Locking을 할 필요가 없다.           
또한 32 X 8로 나누면 SIMD 사용에 용이하다 ( 이것은 나중에 설명하겠다 )            
이렇게 나눈 후 각 타일은 L0 MaxDepth, L1 MaxDepth L1 CoverageMask 값을 가지고 있다.              
          
**L1 CoverageMask**는 현재 삼각형에 의해서 L1 Depth가 얼마나 그려져 있는 지를 나타내는 것이다.            
아래와 같이 32 x 8 타일에서 각 픽셀 당 1비트를 부여해서 1인 경우 삼각형이 그려진 경우, 0인 경우 그려지지 않은 경우이다.                                  
```
0000 0000 0000 0000 0000 0000 0000 0000          
0000 0000 0000 0000 0000 0000 1111 0000          
0000 0000 0000 0000 0000 1111 1111 0000          
0000 0000 0000 0000 1111 1111 1111 0000          
0000 0000 0000 1111 1111 1111 1111 0000          
0000 0000 1111 1111 1111 1111 1111 0000          
0000 0000 0000 0000 0000 0000 0000 0000          
0000 0000 0000 0000 0000 0000 0000 0000          
```

여기서 SIMD 연산이 사용되는 데 위와 같이 삼각형이 있는 경우 우리는 3개의 삼각형의 Edge를 아는 상태이다.      
         
그럼 왼쪽 Edge를 기준으로 1로 모두 채워진 32 x 8 타일을 각 행마다 Shift 연산을 한다.       
그럼 왼쪽 Edge와 각 열이 만나는 위치까지 0으로 채워지고 그 외는 1로 채워진다.     
아래와 같이 말이다.            
이때 SIMD 명령어가 쓰여서 32 x 8 즉 256 bit의 데이터에 대해 하나의 SIMD Shift 명령어로 한번에 아래와 같이 왼쪽 Edge를 기준으로 한 Mask를 채울 수 있다.                      

```
0000 0000 0000 0000 0000 0000 0000 0000          
0000 0000 0000 0000 0000 0000 1111 1111          
0000 0000 0000 0000 0000 1111 1111 1111          
0000 0000 0000 0000 1111 1111 1111 1111          
0000 0000 0000 1111 1111 1111 1111 1111          
0000 0000 1111 1111 1111 1111 1111 1111          
0000 0000 0000 0000 0000 0000 0000 0000          
0000 0000 0000 0000 0000 0000 0000 0000          
```
똑같이 이번에는 오른쪽 Edge를 기준으로 왼쪽 Shift SIMD 명령어를 수행하였다.       
```
1111 1111 1111 1111 1111 1111 1111 0000          
1111 1111 1111 1111 1111 1111 1111 0000          
1111 1111 1111 1111 1111 1111 1111 0000          
1111 1111 1111 1111 1111 1111 1111 0000          
1111 1111 1111 1111 1111 1111 1111 0000          
1111 1111 1111 1111 1111 1111 1111 0000          
0000 0000 0000 0000 0000 0000 0000 0000          
0000 0000 0000 0000 0000 0000 0000 0000          
```

그 후 위의 두 Mask를 AND 연산을 하면 아래와 같이 해당 삼각형이 그려지는 영역(Coverage Mask)를 구할 수 있다.      
```
0000 0000 0000 0000 0000 0000 0000 0000          
0000 0000 0000 0000 0000 0000 1111 0000          
0000 0000 0000 0000 0000 1111 1111 0000          
0000 0000 0000 0000 1111 1111 1111 0000          
0000 0000 0000 1111 1111 1111 1111 0000          
0000 0000 1111 1111 1111 1111 1111 0000                    
0000 0000 0000 0000 0000 0000 0000 0000          
0000 0000 0000 0000 0000 0000 0000 0000               
```

다음으로 **L0 MaxDepth, L1 MaxDepth** 개념에 대해 설명해보겠다.     
개념부터 설명하자면 L0 MaxDepth는 위의 32 x 8 타일을 8 x 4 씩 나누어서 각 8 x 4 타일에 그려진 Occluder의 삼각형 중 가장 Depth 값이 큰(가장 먼) 값을 가진다.      
반면 L1 MaxDepth는 8 x 4 타일에서

우선 하나의 삼각형(Occluder)을 그렸다고 해보자. 

```
-------------------------------------------------------------------         
                                                  1(*, L0 MaxDepth)           
                                                 1        
                                                1        
  카메라                                       1        
                                              1          
                                             1        
                                            1         
-------------------------------------------------------------------               
```
8 x 4 타일 전체를 현재 그린 삼각형이 다 덮었다. ( 다 덮었는지는 위에서 말한 Coverage Mask를 이용하면 된다. )         
그럼 이 삼각형의 가장 먼 위치(*)의 depth 값을 L0 MaxDepth에 저장한다.       
다음으로 또 다른 삼각형(Occluder)을 그렸다.     

```
-------------------------------------------------------------------       
            1                                     1(*, L0 MaxDepth)           
             1                                   1        
              1                                 1        
  카메라       1                               1        
                1(&, L1 MaxDepth)             1          
                                             1        
                                            1          
-------------------------------------------------------------------        
```
새로운 삼각형을 그렸다. 그럼 이 새로운 삼각형의 가장 먼 Depth 값(&)을 L1 MaxDepth에 저장한다.        
이 상황에서 첫번째와 두번째 삼각형 사이에 어떤 오브젝트를 그리면 그 오브젝트는 Cull될까???     
Cull 되는 지를 확인하기 위해서는 그릴 오브젝트의 8 X 4타일 내의 Minimum Depth와 L0 MaxDepth를 비교하면 된다.       
비교하니 새로 그릴 오브젝트의 MinimumDepth 값이 더 작다. 그럼 Cull 되지 않은 것이다.        

자 본론으로 다시 돌아가서 삼각형을 하나 더 그려보겠다.      
```
-------------------------------------------------------------------       
            1                                     1(*, L0 MaxDepth)           
             1                                   1        
              1                                 1        
  카메라       1                               1        
                1(&)                          1          
                          1(^, L1 MaxDepth)  1        
                         1                  1          
-------------------------------------------------------------------        
```
세번째 삼각형을 그렸다. 그리고 세번째 삼각형의 Coverage도 L1 Coverage Mask에 OR 연산으로 추가한다.     
어? L1 Coverage Mask가 모두 1로 가득차 있다. 그럼 이제 우리는 한가지 사실을 확정할 수 있다.         
이 8 X 4 타일의 새로 그려진 삼각형의 최대 Depth(&) 값과 현재 L0 MaxDepth 값(*) 사이에 그려지는 오브젝트는 모드 Cull 된다는 것이다.           
왜냐하면 두번째, 세번째 삼각형에 의해서 8 x 4 Coverage Mask가 다 덮였으니 이 두 삼각형보다 더 멀리 있는 오브젝트들은 이 두 삼각형에 의해 가려지니 렌더링을 할 필요가 없어진 것이다.         

자 그럼 이제 새로운 L1 MaxDepth(^)가 L0 MaxDepth가 되었다. ( Occludee를 그릴 때는 L0 MaxDepth하고 비교한다)     
그리고 L1 Coverage Mask도 0으로 초기화 한다.          
```
-------------------------------------------------------------------       
            1                                     1          
             1                                   1        
              1                                 1        
  카메라       1                               1        
                1                             1          
                          1(^, L0 MaxDepth)  1        
                         1                  1          
-------------------------------------------------------------------        
```

이렇게 L1 Coverage Mask가 다 덮여야만(다 1이여야만) L0 MaxDepth이 새롭게 갱신되는 이유는      
```
안 그려도 될 오브젝트를 그리는 것은 큰 문제가 되지 않지만(어차피 하드웨어에서 Depth Test로 화면에는 안보임)     
그려야할 오브젝트를 그리지 않는 것은 큰 문제가 된다!!!!!!!!
```
그래서 L1 Coverage Mask가 다 덮인 경우 즉 이 L1 MaxDepth 뒤로 그려지는 오브젝트는 무조건 Cull된 다는 것이 확정되어야만 L0 MaxDepth를 갱신하는 것이다.            

또한 각 8 x 4 타일은 MaxDepth Value 즉 4byte짜리 floating-point를 각자 가지기 때문에 8 x 4 타일 8개로 구성된 32 x 8 타일의 각 MaxDepth는 총 4byte * 8개 타일로 32 byte이다.        
이는 32byte 즉 AVX256 SIMD 연산에 적합하기 때문에 8개 타일을 한번의 SIMD 연산으로 갱신할 수 있다는 장점이 있다.         


보시는 바와 같이 Masked SW Occlusion Culling이 빠른 이유는      
```
첫째. 전체 스크린 버퍼를 타일 단위로 나누어서 멀티스레딩 환경에서 하나의 스레드가 하나의 타일은 전담하여 연산함으로서 스레드간 동기화를 거의 배제 할 수 있다는 점        
둘째. 타일의 사이즈 ( 32 * 8 사이즈의 Coverage Mask와 8개의 Sub타일의 MaxDepthValue )가 SIMD 연산에 적합하기 때문에 SIMD 연산으로 여러 타일을 한꺼번에 연산할 수 있다는 장점이 있다.       
```

잘 이해가 되지 않으면 아래의 자료를 보기 바란다 :          
https://www.slideshare.net/IntelSoftware/masked-software-occlusion-culling                       
https://www.slideshare.net/IntelSoftware/masked-occlusion-culling          
